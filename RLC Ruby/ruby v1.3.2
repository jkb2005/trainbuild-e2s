@name RLC Ruby Beta
@inputs Start BatterySwitch LNumber:string MU_Master [Pod]:entity EmBrake UsingRearSeat HEP_Up HEP_Down [Trucks FrontPlugIn RearPlugIn]:array EGPClock:wirelink  EGPDisplay:wirelink BlowedOut
@outputs On Reverser Notch RealNotch Brake HandBrakeOn Dynamics DynaNotch MPH KPH Feet V DynaClag Clag ClagLow ClagHigh LocoBrakePressure Emergency AB16M_Notch LB16M_Notch AB26L LB26L [FrontPlugOut RearPlugOut]:array CarCount WheelSlip Sanding RLCPT:entity Unlocked HEP_Mode Load BrakeInfo:array PrimerState
@persist [Idles Behavior]:array [Transition Startup Shutdown]:string Notch TargetNotch SQ On NQ TQ [UpDelays DownDelays]:array StartupClagStart StartupClagDuration
@persist [DynoOn DynoOff Lever_ReverserF Lever_ReverserN Lever_ReverserB Lever_Throttle Lever_16M Lever_26L]:string
@persist RevQ DynaQ E:entity Starting Dynamics DynamicsEnable DNQ
@persist [Controls Routing]:table Alternate:string
@persist Horsepower TE_Starting TECON W:entity Gearing:string GR
@persist AirBrakeType LocoBrakePressure AB16M_Notch LB16M_Notch ABQ [WheelSound BrakeScreech]:string WQ BQ EMQ BPQ CarCount Threshold_Hard Locked LBQ
@persist [AirBrakeApply AirBrakeRelease Lever_LocoBrake LocoBrakeRelease EmergencyBrakeSound]:string THQ IHQ 
@persist MaxLocoBrakeForce MaxTrainBrakeForce BrakeMul HBQ Lever_HandBrake:string MU_OffsetPitch CarCount_Init O:entity ControlPrintOrder:array
@persist WheelSlipProb ETC [SanderOn SanderOff WheelSlipSound1 WheelSlipSound2]:string SandQ Sanding WSQ WSC
@persist Trig2 OldNotch DPM DPM_Delay DPM_Pitch DPMH:entity DPMS:string HEP HEP_Lock HEPQ
@persist [CompressorOn CompressorOff]:string ER Compressing MaxER AB26L LB26L LB26L_ClickQ BlendedBraking BlendQ InfiniteAir
@persist MainRes EqualRes BrakeLine BrakeCyl Switching
@persist FuelSaver LowIdle:string LowIdling Mode3Q SaverQ SplitShutDowns CFG_HourOffset SecondIncrement MinuteIncrement HourIncrement Primed Priming BatteryOn PrimerSound:string AutoStart BellSound:string
@persist StarterPressed OverrideStart [RR RRName]:string Mode HaveToBlow FrontTruck:entity BackTruck:entity ModeCycle
@trigger Start OverrideStart
@model models/cheeze/beta/white_button.mdl

    AutoStart = 0
    
    
    # Put this to 1 if you want your locomotive to have blow out the moisture from the cylinders, usually on older locomotives (requires extra E2)
    HaveToBlow = 0


    RRName = "UCRR" #Railroad
    Loco = "    " #Locomotive Name
    LNumber = ""
    
#   AutoStart Stuff

    if(AutoStart){
     RR = "Autostart Equipped! | " + RRName
    }else{
     RR = RRName
    }

    
#EGP Base Code
EGPClock:egpAngle(7,(360 -  (SecondIncrement * time("sec"))))
EGPClock:egpAngle(9,(360 -  (MinuteIncrement * time("min"))))
EGPClock:egpAngle(11,(360 - (HourIncrement   * (time("hour") + CFG_HourOffset))))
  SecondIncrement = (360 / 60)
    MinuteIncrement = (360 / 60)
    HourIncrement   = (360 / 12)


    Color1 = vec(255,255,255) #Color 1
    Color2 = vec(0,109,0) #Color 2
    Color3 = vec(50) #Color 3

    EGPDisplay:egpRoundedBox(1,vec2(256),vec2(500))
    EGPDisplay:egpRoundedBox(2,vec2(256),vec2(450))
    EGPDisplay:egpColor(1,Color1)
    EGPDisplay:egpColor(2,Color2)
    EGPDisplay:egpText(3,RR,vec2(50,10))
    EGPDisplay:egpColor(3,Color2)
    EGPDisplay:egpText(4,Loco,vec2(310,10))
    EGPDisplay:egpColor(4,Color2)
    EGPDisplay:egpRoundedBox(5,vec2(256,90),vec2(400,75))
    EGPDisplay:egpColor(5,Color1)
    EGPDisplay:egpRoundedBox(6,vec2(256,180),vec2(400,75))
    EGPDisplay:egpColor(6,Color1)
    EGPDisplay:egpRoundedBox(7,vec2(256,270),vec2(400,75))
    EGPDisplay:egpColor(7,Color1)
    EGPDisplay:egpRoundedBox(8,vec2(256,360),vec2(400,75))
    EGPDisplay:egpColor(8,Color1)
    EGPDisplay:egpText(9,"#"+LNumber,vec2(110,385))
    EGPDisplay:egpColor(9,Color1)
    EGPDisplay:egpFont(9,"",100)
    EGPDisplay:egpText(10,"RLC Ruby By Jaiden",vec2(36,485))
    EGPDisplay:egpColor(10,Color2)



#Brake Code
    H = Dynamics
    J = H:toString()

    EGPDisplay:egpRoundedBox(11,vec2(163,90),vec2(150,50))
    EGPDisplay:egpRoundedBox(12,vec2(347,90),vec2(150,50))
    if(Brake){
        EGPDisplay:egpColor(11,vec(255,0,0))
    }else{
        EGPDisplay:egpColor(11,vec(0,255,0))
    }
    if(Dynamics){
        EGPDisplay:egpColor(12,vec(255,0,0))
    }else{
        EGPDisplay:egpColor(12,vec(0,255,0))
    }

    EGPDisplay:egpText(13,J,vec2(335,65))
    EGPDisplay:egpFont(13,"",50)

#Speed Code
    G = round(MPH,0)
    S = G:toString()

    if(MPH){
        EGPDisplay:egpText(14,"MPH: "+S,vec2(80,155))
}
    
    EGPDisplay:egpFont(14,"",50)
    EGPDisplay:egpColor(14,Color2)
    
#Notch Code
    N = RealNotch:toString()
    
    EGPDisplay:egpText(15,"Notch: "+N,vec2(80,245))
    EGPDisplay:egpFont(15,"",50)
    EGPDisplay:egpColor(15,Color2)
    
#Reverser Code

    EGPDisplay:egpRoundedBox(16,vec2(376,270),vec2(60))
    EGPDisplay:egpColor(16,Color3)
    
    if(Reverser == 1){
        EGPDisplay:egpText(17,"F",vec2(360,245))
    }
    if(Reverser == 0){
        EGPDisplay:egpText(17,"N",vec2(360,245))
    }
    if(Reverser == -1){
        EGPDisplay:egpText(17,"R",vec2(360,245))
    }
    
    EGPDisplay:egpFont(17,"",50)
    EGPDisplay:egpColor(17,Color1)
    
    
#Multiple Unit Code
    if(MU_Master){
        EGPDisplay:egpText(18,"Leading Unit",vec2(80,335))
    }else{
        EGPDisplay:egpText(18,"Slave Unit",vec2(80,335))
    }
    EGPDisplay:egpFont(18,"",50)
    EGPDisplay:egpColor(18,Color2)
    





if(first()|dupefinished()){
hint("This RLC was modified by Engineer Jay! Modified from Alphas RLC Saphire",7) 


    #[
    Beta v4.52 Release canidate 
    
        Welcome to RLC Ruby by Jaiden (Originally By Tyler, Based on Magnum's RLC Platinum V.1.42 but not as stupid of course.)
        Installation is almost the same as RLC AB, except:
            *You need to wire Trucks[ARRAY] to an Adv. Ent marker that is linked to the trucks of the locomotive.
            *Pod[ENTITY] goes to the Pod Controller's "Entity" output (NOT to "Create Entity"!!!)
            *The Starter switch is Non-Toggled
        
    Full Setup Instructions:
        
        1- Configure Locomotive Config and Control Config for your Locomotive
        2- Place chip onto Locomotive body like you would attach a thruster. The Shiny bit needs to face backwards, towards the REAR of the locomotive. DO NOT PARENT IT!
        3- Wire "Start" to a NON-TOGGLED button.
        4- Wire "MU_Master" to a TOGGLED button.
        5a- If you plan on using multiple units: Spawn a wire plug (with the ARRAY tickbox checked) on each end of the locomotive. DO NOT PARENT THEM!
        5b- Wire the Plugs to FrontPlugOut[ARRAY] and RearPlugOut[ARRAY], respectively, and wire FrontPlugIn[ARRAY] and RearPlugIn[ARRAY] to the chip.
        6- Make a bunch of indicators or screens or whatever in the cab so you can see what's going on.
        7- Weight the Locomotive: 40,000 for the Body/Baseplate, 20,000 for each truck. Also, you may want to disable collisions on the Body/Baseplate.
        
    Chat Commands:
    
        .engine - Toggles the Engine.
        .reverser <N> - Changes the Reverser.
        .notch <N> - Changes the engine Notch.
        .brake <N> - Changes the Trainline Brake Pressure. If no argument, applies the Emergency Brake.
        .dynamics <N> - Engages/Disengages the Dynamic Brakes.
        .handbrake - Applies the Handbrake, which gives a rubber physprop to all cars in the consist.
        .controls - Prints the controls to your chat.
        .superice - "super ices" the entire train (Note: actually uses "friction_00").
        .count - Prints the total number of connected cars, assuming 3-prop cars.
        
    Miscellaneous Notes:
    
        The MU System is backwards compatible with RLC, RLC AB, RLC PT, RLC TI, but note the braking code is still a little fucked, I need time to work on that.
        This RLC version is not Recomended to be used on other units that aren't LRI based, RLC Saphire or (RLC SP) has dependency issues and won't like other installs other then what there built on now
        Final note, RLC Sappire is not done. matter of fact it's far from it, i will take bug reports but do not expect help from me to install this on your units, I've given you plenty of warning listed above. 
         
    ]#
    
    #\\\\\\\\\\\\\\\\\\\\\\\\\
    
    local LocomotiveType = "GP35" #The Locomotive model designation, for naming purposes.
    local EngineType = "EMD 567D3A"
    Horsepower = 2500    #Horsepower, Duh
    TE_Starting = 60500 #Starting Tractive effort, in lbf.
    
    #/////////////////////////
    #-----------------
    #Integrated Churros RLC Display Config
    #-----------------
    
    
   
    
    
    #/////////////////////////
    
    DynamicsEnable = 1 #0 for No Dynamic Braking
                       #1 for Normal Dynamic Braking
                       #2 for "Notch 4" Dynamic Braking (ALCO style)
                       #3 for Blended Dynamic Braking (Modern Passenger Locomotives)
    
    ETC = 1 #Electronic Traction Control setting. 0 for no ETC (Hard), 1 for ETC (Easy), 2 to Disable Wheelslip entirely (Lazy).
    
    AirBrakeType = 0 #0 for 16M Airbrakes (Harder), 1 for 26L Airbrakes (Easier).
    
    #26L Airbrakes are more modern, and can provide up to 90psi of pressure. The Increase and Decrease keys will add/subtract pressure for as long as you hold them.
    #16M Airbrakes are older. There are three Notches: "Release," "Lap," and "Apply." While in "Release" or "Apply," the
    #brake pressure will continually increase or decrease until it hits the upper or lower limit. In "Lap," the pressure will be held constant.
    
    Gearing = "62:15" #Traction motor Gear Ratio. 62:15 is the standard freight gearing. Larger 1st numbers trade tractive effort for speed.
    
    HEP = 0 #Set this to 1 if the locomotive is equipped for passenger service and uses the Prime Mover as HEP generators.
    DPM = 0 #if 1, will play an additional prime mover sound in addition to the main one
    BrakeMul = 775 #Don't Touch This
    
    #--------------
    #Control Config
    #--------------
    
    #You can actually change this, but be careful.
    #Wiremod key names do not always coincide with source key names!
    
    Alternate = "lshift" #When pressing this key, all controls with "!ALT" next to them will be triggered, and all the other will be ignored.
    
    Controls["ReverserF",string]        = "W"
    Controls["ReverserB",string]        = "S"
    
    Controls["IncreaseThrottle",string] = "D"
    Controls["DecreaseThrottle",string] = "A"
    
    Controls["IncreaseDynamics",string] = "D !ALT"
    Controls["DecreaseDynamics",string] = "A !ALT"
    
    Controls["IncreaseTrainBrake",string]    = "W !ALT"
    Controls["DecreaseTrainBrake",string]    = "S !ALT"
    
    Controls["IncreaseLocoBrake",string] = "rcontrol"
    Controls["DecreaseLocoBrake",string] = "ralt"
    
    
    Controls["EmergencyBrake",string] = "rshift"
    
    Controls["HandBrake",string] = "H"
    Controls["Sander",string] = "period"
    
    
    
    #Ignore this
    ControlPrintOrder = array("ReverserF","ReverserB","IncreaseThrottle","DecreaseThrottle","IncreaseDynamics","DecreaseDynamics","IncreaseTrainBrake","DecreaseTrainBrake","IncreaseLocoBrake","DecreaseLocoBrake","EmergencyBrake","HandBrake","Sander")
    
    
    
    
    
    #-----------------
    #Sound/Clag Config
    #-----------------
    
    #You probably shouldn't touch anything below here unless you REALLY know what you're doing.
    
    #\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
    
    PrimerSound = "gsgtrainsounds/alco251fv16/prime_loop.wav"  # The sound it makes when the primer starts
    BellSound = "_jazzlok/switches/bell_loop.wav" # The sound for the starting bell.
    
    Startup = "gsgtrainsounds/emd567d3/startup.wav"   #Startup and Shutdown
    Shutdown = "gsgtrainsounds/emd567d3/shutdown.wav"
    
    StartupClagStart = 2      #Clag Config
    StartupClagDuration = 3
    
    Idles = array(                                  #Sounds used for each Notch
    "gsgtrainsounds/emd567d3/idle.wav",
    "gsgtrainsounds/emd567d3/notch1.wav",
    "gsgtrainsounds/emd567d3/notch2.wav",
    "gsgtrainsounds/emd567d3/notch3.wav",
    "gsgtrainsounds/emd567d3/notch4.wav",
    "gsgtrainsounds/emd567d3/notch5.wav",
    "gsgtrainsounds/emd567d3/notch6.wav",
    "gsgtrainsounds/emd567d3/notch7.wav",
    "gsgtrainsounds/emd567d3/notch8.wav"
    )
    Transition = "gsgtrainsounds/emd567d3/transitions/" #The folder path for the transition sounds.
    
                    #1-2  2-3  3-4  4-5  5-6  6-7  7-8 
    UpDelays = array(2000,2400,2400,2500,2650,2750,2800)    #Used for fast notching up/down, don't touch these.
                      #8-7  7-6  6-5  5-4  4-3  3-2  2-1
    DownDelays = array(1800,1750,1800,1850,1900,2000,2200)  
    
    Behavior = array(0,  0,  0,  0,  0,  0,  0,  0)
    #0: Normal A/B Notching
    #1: Full Sweep
    #2: Instant Transition
    #3: No Change
    
    #///////////////////////////////////
    
    LowIdle = "  " #Don't touch these unless you know what you are doing!
    FuelSaver = 0, LowIdling = 0, SplitShutDowns = 0
    
    DynoOn = "gsgtrainsounds/misc/emd_late_dyn_loop.wav"    #Dynamic Brake Sounds
    DynoOff = "gsgtrainsounds/misc/emd_late_dyn_end.wav"
    
    Lever_ReverserF = "_jazzlok/switches/rotary_throttle01.wav"      #Cab Lever Sounds
    Lever_ReverserN = "_jazzlok/switches/rotary_throttle02.wav"
    Lever_ReverserB = "_jazzlok/switches/rotary_throttle03.wav"
    
    Lever_Throttle = "_jazzlok/switches/selector_action.wav" 
    
    Lever_16M = "_jazzlok/switches/throttle_lever02.wav"
    Lever_26L = "gsgtrainsounds/misc/desktop/button_toggle_off.wav"
    
    Lever_LocoBrake = "_jazzlok/switches/throttle_lever03.wav"
    Lever_HandBrake = "_jazzlok/switches/throttle_lever01.wav"
    
    WheelSound = "_jazzlok/traction/wheel_rolling_03_loop.wav"     #Wheel Noises
    BrakeScreech = "_jazzlok/brakes/slippy.wav"             #Brake Screech
    
    AirBrakeApply = "_jazzlok/brakes/air_brake_apply.wav"     #Sounds for Trainline Airbrakes
    AirBrakeRelease = "_jazzlok/brakes/air_brake_hiss_1.wav"   
    
    LocoBrakeRelease = "_jazzlok/switches/throttle_lever04.wav" #Locomotive brakes' apply sounds are very quiet so we just included a release.
    
    EmergencyBrakeSound = "_jazzlok/brakes/brake_valve_flow_emergency.wav"  #The sound of the engineer shitting his pants
    
    CompressorOn = "gsgtrainsounds/misc/compressor_loop.wav"
    CompressorOff = "gsgtrainsounds/misc/compressor_stop.wav"
    
    SanderOn = "gsgtrainsounds/misc/airbrakes/air_sander_loop.wav"    #Not to be confused with Bernie Sanders
    SanderOff = "gsgtrainsounds/misc/airbrakes/air_sander_end.wav"
    
    WheelSlipSound1 = "_jazzlok/brakes/brake_whine_shot03.wav"  #Sounds for Wheelslip
    WheelSlipSound2 = "_jazzlok/brakes/brake_whine_shot01.wav"
    
    Threshold_Hard = 0.25 #Speed, in mph, below which the train brakes will hold the train.
    
    
    DPM_Delay = 200 #Delay in ms for the 2nd prime mover to get the message
    DPM_Pitch = 2 #Extra Pitch to give the 2nd Prime Mover
    
    
    #Sound Index Register (You don't need to know this)
    
    #0 - Engine Sounds
    #1 - Cab Levers
    #2 - Dynamic Brake Fans
    #3 - Wheel Sound
    #4 - Brake Screech
    #5 - Train Brake Hiss
    #6 - Sander
    #7 - Dual Prime Mover
    #8 - Air Compressor
    
    
    #----
    #Init
    #----
    
    
    #Controls Init
    
    foreach(K,V:string = Controls){
        if(V:find(" !ALT")){
            Routing[K,number] = 1
            local EXP = V:explode(" ")
            Controls[K,string] = EXP[1,string]
        }else{
            Routing[K,number] = 0
        }
    }
    
    #Sounds Init
    
    #DPM
    if(DPM){
        DPMH = holoCreate(0,entity():isWeldedTo():pos(),vec(1),ang(),vec(255),"cube")
        holoParent(0,entity())
        DPMH:propDraw(0)
        
    }
    
    function void lowidlestop(){
        stoptimer("lowidlestart")
        #print("                Stopping Timer")
        SaverQ = 0
    }
    
    #Tickrate-Adjusted Sound Duration
    function number sdr(Soundpath:string){
        local Tick = round(1/tickInterval())
        
        return floor(soundDuration(Soundpath)*100)*10/((Tick==33) ? 2 : 1)
    }
    
    function number startTransition(From,To){
        lowidlestop()
        
        if(To > From){
            Clag = 1
            
            local BType = Behavior[From+1,number]
            if(LowIdling){
                #LowIdling = 0
                LowIdling = 0
                local Snd = Transition + "up/low_idle-0.wav"
                W:soundPlay(0,0,Snd)
                if(DPM & !HEP_Lock){
                    DPMS = Snd
                    timer("dpm",DPM_Delay)
                }
                timer("level",sdr(Snd))
                
                
                return From+1
            }elseif(BType==1){
                #Full Sweep
                #local Snd = Transition + "up/low_idle-0.wav"
                local Nc = From:toString()
                local Nn = (From+1):toString()
                local Snd = Transition + "up/" + Nc + "-" + Nn + ".wav"
                if(!HEP_Lock){W:soundPlay(0,0,Snd)}
                local SDR = sdr(Snd)
                timer("level",SDR)
                timer("manclag",floor(SDR/20)*10)
                Mode3Q = 0
                #print("============Full")
                return From 
                
                if(DPM & !HEP_Lock){
                    DPMS = Snd
                    timer("dpm",DPM_Delay)
                }
            }elseif(BType==0){
                #Normal AB
                local Nc = From:toString()
                local Nn = (From+1):toString()
                local Snd = Transition + "up/" + Nc + "-" + Nn + "a.wav"
                if(!HEP_Lock){W:soundPlay(0,0,Snd)}
                timer("abu",sdr(Snd)-50)
                return From
                
                if(DPM & !HEP_Lock){
                    DPMS = Snd
                    timer("dpm",DPM_Delay)
                }
            }elseif(BType>=2){
                timer("level",500)
                if(BType==3){
                    Mode3Q = 1
                }
                return From+1
                
            
                
            }
        }elseif(To < From){
            Clag = 0
            local BType = Behavior[From,number]
            #print("                                " + BType)
            #Pod:printDriver(BType:toString())
            if(BType==1){
                #Full Sweep
                local Nc = From:toString()
                local Nn = (From-1):toString()
                local Snd = Transition + "down/" + Nc + "-" + Nn + ".wav"
                if(!HEP_Lock){W:soundPlay(0,0,Snd)}
                timer("level",sdr(Snd))
                Mode3Q = 0
                #print("============Full")
                return From-1
                
                if(DPM & !HEP_Lock){
                    DPMS = Snd
                    timer("dpm",DPM_Delay)
                }
            }elseif(BType==0){
                #Normal AB
                local Nc = From:toString()
                local Nn = (From-1):toString()
                local Snd = Transition + "down/" + Nc + "-" + Nn + "a.wav"
                if(!HEP_Lock){W:soundPlay(0,0,Snd)}
                timer("abd",sdr(Snd)-50)
                return From
                
                if(DPM & !HEP_Lock){
                    DPMS = Snd
                    timer("dpm",DPM_Delay)
                } 
            }elseif(BType>=2){
                timer("level",500)
                
                if(BType==3){
                    Mode3Q = 1
                }
                return From-1
                
            }
        }else{
            return From
        }
        
    }
    function number tq_evaluate(From,To){
        return    (From!=To)
    }
    function void entity:printProper(Message:string){
        if(This==O){
            print(Message)
        }else{
            Pod:printDriver(Message)
        }
    }
    
    #Locomotive Init
    Notch = 0
    RealNotch = 0
    Reverser = 0
    AB16M_Notch = AirBrakeType ? 0 : 1
    LB16M_Notch = -1
    
    function number entity:extraProps(Init){
        local Extra = Switching ? 0 : floor((E:getConstraints():count() - Init)/3)
        MaxTrainBrakeForce = BrakeMul*Extra/(70)
        return Extra
        
    }
    function void array:abRest(){
        
        foreach(K,V:entity = This){
            V:propPhysicalMaterial("phx_tire_normal")
        }
    }
    function void entity:abRelease(){
        local Ents = E:getConstraints()
        foreach(K,V:entity = Ents){
            V:propPhysicalMaterial("friction_00")
        }
    }
   
    
    
    #Misc Init 
    
    Starting = 0
    SQ = 0
    On = 0
    NQ = 0
    DNQ = 0
    TQ = 0
    Notch = 0
    RealNotch = 0
    DynaNotch = -1
    Clag = 0
    RevQ = 0
    DynaQ = 0
    BlendQ = 0
    RLCPT = E = entity()
    O = owner()
    ABQ = 0
    LBQ = 0
    WQ = 0
    BQ = 0
    Mode3Q = 0
    
    local GetGears = Gearing:explode(":")
    local GIn = GetGears[1,string]:toNumber()
    local GOut = GetGears[2,string]:toNumber()
    
    local GearRatio = GOut/GIn
    GR = GearRatio*62/12
    
    MainRes = 0
    EqualRes = 0
    BrakeLine = 0
    BrakeCyl = 0
    
    #MaxER = AirBrakeType ? 90 : 70
    #AB26L = AirBrakeType ? 45 : 0
    #LB26L = 0
    #TrainBrakePressure = MaxER/2
    LocoBrakePressure = 0
    #ER = 0
    
    BrakeInfo = array(MainRes,EqualRes,BrakeLine,LocoBrakePressure,BrakeCyl)
    
    LB26L_ClickQ = 0
    BPQ = 0
    EMQ = 0
    Locked = 0
    Emergency = 0
    HandBrakeOn = 0
    THQ = IHQ = 0
    HBQ = 0
    
    WheelSlipProb = 1/64
    SandQ = 0
    Sanding = 0
    WSQ = 0
    WSC = 0
    
    Trig2 = 0
    OldNotch = 0
    #HEP_Notch = 0
    HEP_Mode = 0
    HEPQ = 0
    
    Switching = 0
    
    
    
    FrontPlugOut = array()
    RearPlugOut = array()
    
    W = E:isWeldedTo()
    
    E:setSubMaterial(2,"bobsters_trains/br_virgin_red")
    
    CarCount_Init = E:getConstraints():count()
    
    MaxLocoBrakeForce = 300000/70
    MaxTrainBrakeForce = 0
    
    
    runOnChat(1)
    
    setName("RLC Ruby Public Release: "+EngineType+"\n"+LocomotiveType)
}
#=============================
#Startup & Shutdown, Misc Clks
#=============================



if(changed(BatterySwitch) & BatterySwitch == 0){
 BatteryOn = 0
 soundStop(3483,2)   
}
if(BatterySwitch){
       
if(Start & AutoStart & !StarterPressed & !On){
    StarterPressed = 1
    soundPlay(3484,0,BellSound)
    timer("StopBell",10000)
}

if(clk("StopBell")){
 StarterPressed = 0
 stoptimer("StopBell")
 soundStop(3484,2)
 timer("StopStart",10500)
 OverrideStart = 1
}

if(clk("StopStart")){
 stoptimer("StopStart")
OverrideStart = 0
}
    if(BatteryOn == 0){
        BatteryOn = 1
    soundPlay(3483,0,"_jazzlok/switches/hum.wav")  
    soundVolume(3483,0.25)
    }
if(Start & !SQ & !AutoStart | OverrideStart & AutoStart & !SQ | On & Start & !SQ & AutoStart){
    if(On == 0){
            if(HaveToBlow & BlowedOut | !HaveToBlow){
    PrimerState = 1
    timer("StartPrime",10000)
    if(Priming == 0){  #Debounce for the sound Priming is really only used for the sound.
    Priming = 1
    soundPlay(3482,0,PrimerSound)
}
}
    if(clk("StartPrime")){

     Primed = 1   
     Priming = 0
     PrimerState = 2
    soundStop(3482,3)
    }
}
    if(Primed){
    SQ = 1
    Starting = !Starting
    if(Starting){
        local Snd = (FuelSaver & SplitShutDowns) ? (LowIdling ? Startup:sub(1,Startup:length()-4) + "_low.wav" : Startup) : Startup
        W:soundPlay(0,0,Snd)
        timer("run",10*floor(soundDuration(Snd)*50) - 500)
        timer("startclag",StartupClagStart*1000)
        
        if(DPM){
            DPMS = Snd
            timer("dpm",sdr(Snd)-500)
        }
        
    }else{
        On = 0
        FrontPlugOut = array()
        RearPlugOut = array()
        local Snd = (FuelSaver & SplitShutDowns) ? (LowIdling ? Shutdown:sub(1,Shutdown:length()-4) + "_low.wav" : Shutdown) : Shutdown
        W:soundPlay(0,0,Snd)
        stopAllTimers()
        timer("cool",10*floor(soundDuration(Snd)*50))
        if(DPM){
            DPMS = Snd
            timer("dpm",sdr(Snd))
        }
        Primed = 0
    }
}
}elseif(!Start & SQ){
    SQ = 0

    Priming = 0
}
}
if(Starting & clk("run")){
    On = 1
    PrimerState = 0
    W:soundPlay(0,0,LowIdling ? LowIdle : Idles[1,string])
    RealNotch = 0
    Notch = 0
    timer("count",10000)
    CarCount = E:extraProps(CarCount_Init)
    if(DPM){
        #print("Run")
        DPMS = LowIdling ? LowIdle : Idles[1,string]
        timer("dpm",sdr(Startup))
    }
    #Compressing = 1
    #W:soundPlay(8,0,CompressorOn)
    #if(!MU_Master){TrainBrakePressure=0}
    
}
if(clk("cool")){
    soundStop(0)
    if(Compressing){
        W:soundPlay(8,2,CompressorOff)
        Compressing = 0
    }
    #ER = 0
        
}elseif(clk("startclag")){
    Clag = 1
    DynaClag = 1
    timer("endclag",StartupClagDuration*1000)
}elseif(clk("endclag")){
    Clag = 0
    DynaClag = 0
}elseif(clk("count")){
    CarCount = E:extraProps(CarCount_Init)
    
    if(MU_Master){
        MU_OffsetPitch = 0
    }else{
        local CF = (FrontPlugIn:count()>=5)
        local CR = (RearPlugIn:count()>=5)
        MU_OffsetPitch = (CF&CR) ? -2 : 2
    }
    if(!Compressing & (MainRes > 0)){MainRes += -1}
    timer("count",5000)
}elseif(clk("THQ")){
    THQ = 0
    soundStop(5)
}elseif(clk("IHQ")){
    IHQ = 0
    soundStop(5)
}elseif(clk("manclag")){
    RealNotch++
}elseif(clk("WheelSlipEnd")){
    WheelSlip = 0
    soundStop(7)
    WSQ = 1
    timer("WheelSlipStart",500)
}elseif(clk("WheelSlipStart")){
    WSQ = 0
}elseif(clk("mu_recheck")){

    if(DynamicsEnable){
        local MU_Dynamics = FrontPlugIn[4,number] + RearPlugIn[4,number]
        if(MU_Dynamics & !Dynamics){
            Dynamics = 1
        }elseif(!MU_Dynamics & Dynamics){
            Dynamics = 0 
        }
    }
    
    local NotchMU = 0.8*(FrontPlugIn[2,number] + RearPlugIn[2,number])
    
    if(!Dynamics & (Notch!=NotchMU)){
        Notch = NotchMU
        TQ = tq_evaluate(RealNotch,Notch)
        RealNotch = startTransition(RealNotch,Notch)
    }elseif(Dynamics & DynaNotch!=NotchMU){
        DynaNotch = NotchMU
        if(DynamicsEnable==1){
            Notch = DynaNotch>-1 ? DynaNotch : 0
            if(!TQ){
                TQ = tq_evaluate(RealNotch,Notch)
                RealNotch = startTransition(RealNotch,Notch)
            }
        }
    }
}elseif(clk("dpm")){
    DPMH:soundPlay(7,0,DPMS)
    #print(DPMS)
    soundPitch(7,100+DPM_Pitch)
}elseif(clk("highidle")){
    #print("highidle")
    local Snd = Idles[1,string]
    W:soundPlay(0,0,Snd)
    if(DPM & !HEP_Lock){
        DPMS = Snd
        timer("dpm",DPM_Delay)
    }
}elseif(clk("lowidlestart")){
    #print("lowidlestart")
    
    LowIdling = 1
    local Snd = Transition + "down/0-low_idle.wav"
    W:soundPlay(0,0,Snd)
    if(DPM & !HEP_Lock){
        DPMS = Snd
        timer("dpm",DPM_Delay)
    }
    timer("lowidle",sdr(Snd))
}elseif(clk("lowidle")){
    #print("lowidle")
    W:soundPlay(0,0,LowIdle)
    if(DPM & !HEP_Lock){
        DPMS = LowIdle
        timer("dpm",DPM_Delay)


  }

}


#==============
#Engine Running
#==============


if(On){
    interval(50)
    
    if(Trig2){
        Trig2 = 0
        Trig = 1
    }else{
        Trig = 0
    }
    
    #------------------
    #Control Resolution
    #------------------
    
    Driver = Pod:driver()
    
    if(Driver & MU_Master){
        
        local Shifting = Driver:keyPressed(Alternate)
        
        local RF = UsingRearSeat ? "ReverserB" : "ReverserF"
        local RB = UsingRearSeat ? "ReverserF" : "ReverserB"
        
        ReverserF = Driver:keyPressed(Controls[RF,string]) & (Routing[RF,number] ? Shifting : !Shifting)
        ReverserB = Driver:keyPressed(Controls[RB,string]) & (Routing[RB,number] ? Shifting : !Shifting)
        
        IncreaseThrottle = Driver:keyPressed(Controls["IncreaseThrottle",string]) & (Routing["IncreaseThrottle",number] ? Shifting : !Shifting)
        DecreaseThrottle = Driver:keyPressed(Controls["DecreaseThrottle",string]) & (Routing["DecreaseThrottle",number] ? Shifting : !Shifting)
        
        IncreaseTrainBrake = Driver:keyPressed(Controls["IncreaseTrainBrake",string]) & (Routing["IncreaseTrainBrake",number] ? Shifting : !Shifting)
        DecreaseTrainBrake = Driver:keyPressed(Controls["DecreaseTrainBrake",string]) & (Routing["DecreaseTrainBrake",number] ? Shifting : !Shifting)
        
        IncreaseLocoBrake = Driver:keyPressed(Controls["IncreaseLocoBrake",string]) & (Routing["IncreaseLocoBrake",number] ? Shifting : !Shifting)
        DecreaseLocoBrake = Driver:keyPressed(Controls["DecreaseLocoBrake",string]) & (Routing["DecreaseLocoBrake",number] ? Shifting : !Shifting)
        
        if(DynamicsEnable){
            IncreaseDynamics = Driver:keyPressed(Controls["IncreaseDynamics",string]) & (Routing["IncreaseDynamics",number] ? Shifting : !Shifting)
            DecreaseDynamics = Driver:keyPressed(Controls["DecreaseDynamics",string]) & (Routing["DecreaseDynamics",number] ? Shifting : !Shifting)
        }
        EmergencyBrake = Driver:keyPressed(Controls["EmergencyBrake",string]) & (Routing["EmergencyBrake",number] ? Shifting : !Shifting)
        
        HandBrake = Driver:keyPressed(Controls["HandBrake",string]) & (Routing["HandBrake",number] ? Shifting : !Shifting)
        Sander = Driver:keyPressed(Controls["Sander",string]) & (Routing["Sander",number] ? Shifting : !Shifting)
        
    }elseif(!MU_Master){
        #------------
        #MU Receiving
        #------------
        
        if(FrontPlugIn[5,number] | RearPlugIn[5,number]){
            stoptimer("mu_recheck")
            timer("mu_recheck",1000)
            
            Reverser = -FrontPlugIn[1,number] + RearPlugIn[1,number]
            
            
            
            
            
            
            #print("Recv")
            
            
            
            if(DynamicsEnable){
                local MU_Dynamics = FrontPlugIn[4,number] + RearPlugIn[4,number]
                if(MU_Dynamics & !Dynamics){
                    Dynamics = 1
                }elseif(!MU_Dynamics & Dynamics){
                    Dynamics = 0 
                }
            }
            
            local ThrottleMU = FrontPlugIn[2,number] + RearPlugIn[2,number]
            Notch = Dynamics ? Notch : ThrottleMU*0.8
            DynaNotch = Dynamics ? ThrottleMU*0.8 : -1
            
            if(!Dynamics){
                TQ = tq_evaluate(RealNotch,Notch)
                RealNotch = startTransition(RealNotch,Notch)
            }
            
            Sanding = FrontPlugIn[6,number] + RearPlugIn[6,number]
            
        }
    }
    
    #-----------------
    #Engine Sound Code
    #-----------------
    
    #Notch Up By Control
    if(IncreaseThrottle & !NQ & (Notch<8) & !Dynamics){
        NQ = 1
        Notch++
        if(!TQ){
            #TQ = RealNotch==0 ? 0 : 1
            
            
            TQ = tq_evaluate(RealNotch,Notch)
            RealNotch = startTransition(RealNotch,Notch)
            
            
            Pod:soundPlay(1,0.5,Lever_Throttle)
        }
        Trig = 1
    }
    
    if(clk("abu")){
        #print("ab up")
        local Nc = RealNotch:toString()
        local Nn = (RealNotch+1):toString()
        local Snd = Transition + "up/" + Nc + "-" + Nn + "b.wav"
        RealNotch++
        if(!HEP_Lock){W:soundPlay(0,0,Snd)}   
        if((RealNotch < Notch) & (Behavior[RealNotch,number]==0)){
            timer("abu",UpDelays[RealNotch-1,number])
            #print(UpDelays[RealNotch-1,number])
        }else{
            timer("level",sdr(Snd)-50)
            Mode3Q = 0
        }
        
        if(DPM & !HEP_Lock){
            DPMS = Snd
            timer("dpm",DPM_Delay)
        }
    }
    
    #Notch Down By Control
    
    if(DecreaseThrottle & !NQ & (Notch>0) & !Dynamics){
        NQ = 1
        Notch--
        if(!TQ){
            #TQ = RealNotch==1 ? 0 : 1
            
            TQ = tq_evaluate(RealNotch,Notch)
            RealNotch = startTransition(RealNotch,Notch)
            
            Pod:soundPlay(1,0.5,Lever_Throttle)
        }
        Trig = 1
    }
    if(!IncreaseThrottle & !DecreaseThrottle & NQ){
        NQ = 0
    }
    
    if(clk("abd")){
        #print("ab down")
        local Nc = RealNotch:toString()
        local Nn = (RealNotch-1):toString()
        local Snd = Transition + "down/" + Nc + "-" + Nn + "b.wav"
        #print(Snd)
        RealNotch--
        if(!HEP_Lock){W:soundPlay(0,0,Snd)}
        if((RealNotch > Notch) & (Behavior[RealNotch,number]==0)){
            timer("abd",DownDelays[8-RealNotch,number])
            #print(DownDelays[8-RealNotch,number])
        }else{
            timer("level",sdr(Snd)-50)
            Mode3Q = 0
            #print("descending to " + (RealNotch-1))
        }
        
        if(DPM & !HEP_Lock){
            DPMS = Snd
            timer("dpm",DPM_Delay)
        }
    }
    
    #Leveling Out
    if(clk("level")){
        #print("----------------------Leveling at N" + RealNotch + ", Mode3Q = " + Mode3Q)
        if(RealNotch == Notch){
            Clag = 0
            if(!HEP_Lock & !Mode3Q){
                W:soundPlay(0,0,Idles[RealNotch+1,string])
                
            }
            
            Mode3Q = 0
            soundPitch(0,100+MU_OffsetPitch)
            TQ = 0
            #print("levelout")
            if(DPM & !HEP_Lock){
                DPMS = Idles[RealNotch+1,string]
                timer("dpm",DPM_Delay)
            }
            if(HEPQ){
                HEPQ = 0
                HEP_Lock = (HEP_Mode>0)
                Notch = RealNotch = 0
            }
        }else{
            TQ = 1
            RealNotch = startTransition(RealNotch,Notch)
            
            #print("This is what is happening!")
            local BType = Behavior[RealNotch+1,number]
            #print("                            "+BType)
            if(BType>=2){
                W:soundPlay(0,0,Idles[RealNotch+1,string])
            }
            
        }
    }
    
    #Count Clagula V3
    #Clag = Notch > RealNotch
    
    #----------------------------------
    #Shit you have to be in Notch 0 for
    #----------------------------------
    if(RealNotch==0){
        
        #Reverser
        
        if(ReverserF & !RevQ & (Reverser<1) & (!Dynamics)){
            RevQ = 1
            Reverser++
            Pod:soundPlay(1,1,Reverser==1 ? Lever_ReverserF : Lever_ReverserN)
            Trig = 1
        }elseif(ReverserB & !RevQ & (Reverser>-1) & (!Dynamics)){
            RevQ = 1
            Reverser--
            Pod:soundPlay(1,1,Reverser==-1 ? Lever_ReverserB : Lever_ReverserN)
            Trig = 1
        }elseif(!ReverserF & !ReverserB & RevQ){
            RevQ = 0
        }
        
        #Fuel Saver
        if(FuelSaver){
            if((Reverser!=0) & LowIdling==1){
                LowIdling = 0
                local Snd = Transition + "up/low_idle.wav-1"
                W:soundPlay(0,0,Snd)
                if(DPM & !HEP_Lock){
                    DPMS = Snd
                    timer("dpm",DPM_Delay)
                }
                timer("highidle",sdr(Snd))
                lowidlestop()
                
            }elseif((Reverser!=0) & !LowIdling & SaverQ){
                lowidlestop()
            
            
            }elseif((Reverser==0) & !LowIdling & !SaverQ){
                
                lowidlestop()
                SaverQ = 1
                timer("lowidlestart",10000)
                #print("                  Starting Timer")
            }
        }
        
        #HEP Switch
        
        if(HEP){
            if(Reverser==0 & !HEPQ){
                if(HEP_Up & (HEP_Mode<2)){
                    HEPQ = 1
                    HEP_Lock = 0
                    HEP_Mode++
                    Notch = HEP_Mode*4
                    TQ = tq_evaluate(Notch-4,Notch)
                    RealNotch = startTransition(Notch-4,Notch)
                    
                    
                }elseif(HEP_Down & (HEP_Mode>0)){
                    HEPQ = 1
                    HEP_Lock = 0
                    HEP_Mode--
                    Notch = HEP_Mode*4  
                    TQ = tq_evaluate(Notch+4,Notch)
                    RealNotch = startTransition(Notch+4,Notch)
                }
            }
        }
    }
    #--------------
    #Dynamic Brakes
    #--------------
    if(DynamicsEnable){
        if(IncreaseDynamics & !DNQ & (DynaNotch<8)){
            #print("blah")
            DNQ = 1
            
            local CanEngage = (DynaNotch==-1) ? (RealNotch==0) : 1
            if((Reverser!=0) & CanEngage){
                DynaNotch++
                Pod:soundPlay(1,1,Lever_Throttle)
                Trig = 1
                if(DynamicsEnable==1){
                    Notch = DynaNotch
                    if(!TQ){
                        TQ = tq_evaluate(RealNotch,Notch)
                        RealNotch = startTransition(RealNotch,Notch)
                    }
                }
            }
            Dynamics = DynaNotch > -1
            
        }elseif(DecreaseDynamics & !DNQ & (DynaNotch>-1)){
            DNQ = 1
            
            if(Reverser!=0){
                DynaNotch--
                Pod:soundPlay(1,1,Lever_Throttle)
                Trig = 1
                if(DynamicsEnable==1){
                    Notch = DynaNotch > -1 ? DynaNotch : 0
                    if(!TQ){
                        TQ = tq_evaluate(RealNotch,Notch)
                        RealNotch = startTransition(RealNotch,Notch)
                    }
                }
            }
            Dynamics = DynaNotch > -1
        }elseif(!IncreaseDynamics & !DecreaseDynamics & DNQ){
            DNQ = 0
        }
        #Dynamics = DynaNotch > 0
        
        if(Dynamics & !DynaQ){
            DynaQ = 1
            W:soundPlay(2,0,DynoOn)
            if(DynamicsEnable==2){
                Notch = 4
                TQ = tq_evaluate(RealNotch,Notch)
                RealNotch = startTransition(RealNotch,Notch)
            }
        }elseif(!Dynamics & DynaQ){
            DynaQ = 0
            W:soundPlay(2,7,DynoOff)
            if(DynamicsEnable==2){
                Notch = 0
                TQ = tq_evaluate(RealNotch,Notch)
                RealNotch = startTransition(RealNotch,Notch)
            }
        }
        
    }
    #Blended Braking
    if(DynamicsEnable==3){
        
        local Blend = ((90-BrakeLine)>=10) & (MPH>5)
        #print(MU_Dynamics)
        if(Blend & !BlendQ & (Reverser!=0)){
            BlendQ = 1
            Dynamics = 1
            HEP_Lock = 1
            DynaNotch = 0
            #Pod:soundPlay(1,1,Lever_Throttle)
            #W:soundPlay(2,0,DynoOn)
            #print("Blend on")
            
        }elseif((!Blend | (Reverser==0)) & BlendQ){
            BlendQ = 0
            Dynamics = 0
            DynaNotch = -1
            HEP_Lock = (HEP_Mode>0)
            #W:soundPlay(2,7,DynoOff) 
            #print("Blend Off")
        }
        
    }
    
    #-----------------------
    #Velocity Info Gathering
    #-----------------------
    
    V = -E:velL():z()
    MPH = abs(toUnit("mph",V))
    KPH = abs(toUnit("km/h",V))
    
    Moving = MPH>Threshold_Hard
    #Wheel Sound
    if(Moving){
        if(!WQ){
            WQ = 1
            W:soundPlay(3,0,WheelSound)
        }
        soundPitch(3,MPH*3.3)
    }elseif(!Moving & WQ){
        WQ = 0
        soundStop(3)
    }
    
    
    #----------------------------
    #Instantaneous TE Calculation
    #----------------------------
    
    if(Reverser!=0 & !Dynamics & !HEPQ & (HEP_Mode != 1)){
        local Throttle = min(RealNotch,Notch)
        local TEG = TE_Starting*GR
        local HPG = Horsepower/GR
        TE = 2*Reverser*TEG*Throttle*exp(-100*MPH/HPG)
        
        
        
    }else{
        TE = 0
    }
    
    
    #--------------------------
    #Dynamic Brake Calculations
    #--------------------------
    
    if(Dynamics & DynamicsEnable){
        local Rightway = sign(V)==sign(Reverser)
        local Throttle = DynaNotch
        DynaForce = Reverser*(MPH*MPH)*Throttle*Horsepower*Rightway/16
        
    }else{
        DynaForce = 0
    }
    #==========================
    #Train Brake And Loco Brake
    #==========================
    
    local MU_Connected = (FrontPlugIn:count() + RearPlugIn:count()) > 5
    if(!MU_Master & MU_Connected){
        MainRes = FrontPlugIn[9,number] + RearPlugIn[9,number]
        #EqualRes = 90
        AB16M_Notch = -1
    }
    local NumCompressors = FrontPlugIn[8,number] + RearPlugIn[8,number] + 1
    
    
    
    #----------
    #Compresors
    #----------
    if((MainRes<30) & !Compressing){
        Compressing = 1
        W:soundPlay(8,0,CompressorOn)
    }elseif((MainRes>150) & Compressing){
        Compressing = 0
        W:soundPlay(8,4,CompressorOff)
    }
    if(Compressing){MainRes += 0.5*NumCompressors}
    
    #--------------------
    #Equalizing Reservoir
    #--------------------
    
    if(AirBrakeType){
        #26L Trainline
        if(IncreaseTrainBrake & (EqualRes>0) & !ABQ){
            ABQ = 1
            Pod:soundPlay(1,1,Lever_26L)
        }elseif(DecreaseTrainBrake & (EqualRes<90) & !ABQ){
            ABQ = 1
            Pod:soundPlay(1,1,Lever_26L)
        }elseif(!DecreaseTrainBrake & !IncreaseTrainBrake & ABQ){
            ABQ = 0
        }
        AB16M_Notch = IncreaseTrainBrake - DecreaseTrainBrake
    }else{
        #16M Trainline
        if(IncreaseTrainBrake & (AB16M_Notch<1) & !ABQ){
            ABQ = 1
            Pod:soundPlay(1,1,Lever_16M)
            AB16M_Notch++
        }elseif(DecreaseTrainBrake & (AB16M_Notch>-1) & !ABQ){
            ABQ = 1
            Pod:soundPlay(1,1,Lever_16M)
            AB16M_Notch--
        }elseif(!DecreaseTrainBrake & !IncreaseTrainBrake & ABQ){
            ABQ = 0
        }
        
    }
    #ER Hiss
    if((AB16M_Notch==1) & (EqualRes>0) & !THQ){
        THQ = 1
        Pod:soundPlay(5,4,AirBrakeApply)
        timer("THQ",6000)
    }elseif((AB16M_Notch==-1) & (EqualRes<90) & !THQ){
        THQ = 1
        Pod:soundPlay(5,4,AirBrakeRelease)
        timer("THQ",6000)
    }
    #ER Indexing
    if((AB16M_Notch==1) & (EqualRes>0)){
        EqualRes--
    }elseif((AB16M_Notch==-1) & (EqualRes<90)){
        EqualRes++
    }
    #----------
    #Brake Line
    #----------
    if(changed(CarCount) & (($CarCount)>0)){
        BrakeLine *= (CarCount - $CarCount)/CarCount
    }
    if(BrakeLine > EqualRes){
        #Apply
        BrakeLine -= 1/(CarCount/16 + 1)
        
        
    }elseif(BrakeLine < EqualRes){
        #Release
        if(MainRes >= 30){
            MainRes -= 0.125*(CarCount/4 + 1)/NumCompressors
            BrakeLine += 1/(CarCount/16 + 1)
        }
    }
    if(abs(EqualRes-BrakeLine)<=(1/(CarCount/16 + 1))){
        BrakeLine = EqualRes
    }
    
    #----------------
    #Locomotive Mode
    #----------------
    
    if(ModeCycle){
     Mode = !Mode   
    }
    
    if(changed(Mode) & Mode){
        
        print("Locomotive Set to 'Switching Mode'")
        FrontTruck:propPhysicalMaterial("Metal")
       
    }elseif(changed(Mode) & !Mode){

        print("Locomotive Set to 'Running Mode'")
        FrontTruck:propPhysicalMaterial("Super Ice")
    
    }
    
    
    
    
    
    
    
    #----------------
    #Locomotive Brake
    #----------------
    if(AirBrakeType){
        #26L Independent
        LB16M_Notch = IncreaseLocoBrake - DecreaseLocoBrake
        if(IncreaseLocoBrake & (LocoBrakePressure==90) & !LB26L_ClickQ){
            LB26L_ClickQ = 1
            Pod:soundPlay(1,1,Lever_LocoBrake)
        }elseif(LocoBrakePressure<90){
            LB26L_ClickQ = 0
        }
    }else{
        #16M Independent
        if(IncreaseLocoBrake & (LB16M_Notch<1) & !LBQ){
            LBQ = 1
            LB16M_Notch++
            if(LB16M_Notch==1){Pod:soundPlay(1,1,Lever_LocoBrake)}
        }elseif(DecreaseLocoBrake & (LB16M_Notch>-1) & !LBQ){
            LBQ = 1
            LB16M_Notch--
        }elseif(!DecreaseLocoBrake & !IncreaseLocoBrake & LBQ){
            LBQ = 0
        }
    }
    #LB Hiss
    if((LB16M_Notch==-1) & (LocoBrakePressure>0) & !IHQ){
        IHQ = 1
        Pod:soundPlay(5,4,LocoBrakeRelease)
        timer("IHQ",6000)
    }
    
    #LB Indexing
    if((LB16M_Notch==1) & (LocoBrakePressure<90)){
        LocoBrakePressure++
    }elseif((LB16M_Notch==-1) & (LocoBrakePressure>0)){
        LocoBrakePressure--
        
        if(LocoBrakePressure>(90-BrakeLine)){MainRes -= 0.125/NumCompressors}
    }
    
    #Cylinder
    BrakeCyl = max(LocoBrakePressure,90-BrakeLine)/2.5
    
    #Brake Info Array
    BrakeInfo = array(MainRes,EqualRes,BrakeLine,LocoBrakePressure,BrakeCyl)
    
    #Emergency Brake
    if((EmergencyBrake | EmBrake) & !Emergency){
        Emergency = 1
        BrakeLine = 0
        EqualRes = 0
        AB16M_Notch = 2
        
        local Ents = E:getConstraints()
        foreach(K,V:entity=Ents){
            V:propPhysicalMaterial("slipperyslime")
        }
        
        Pod:soundPlay(5,0,EmergencyBrakeSound)
        Pod:soundPlay(1,1,AirBrakeType ? Lever_26L : Lever_16M)
        
        
        Notch = 0
        TQ = tq_evaluate(RealNotch,Notch)
        RealNotch = startTransition(RealNotch,Notch)
        
        Trig = 1
    }
    
    Brake = (BrakeCyl > 0)
    
    #Brake Screeching Sounds
    local Screech = Moving & Brake & (MPH<8)
    if(Screech & !BQ){
            BQ = 1
        W:soundPlay(4,0,BrakeScreech)
    }elseif(!Screech & BQ){
        BQ = 0
        soundStop(4)
    }
    
    #Train Brake Physprops
    if(Brake & (MPH<Threshold_Hard) & !BPQ){
        BPQ = 1
        Trucks:abRest()
        Locked = 1
        
    }elseif(!Brake & BPQ){
        BPQ = 0
        E:abRelease()
        Locked = 0
        Emergency = 0
        HandBrakeOn = 0
        CarCount = E:extraProps(CarCount_Init)
    }
    
    #Handbrake
    if(HandBrake & !HBQ){
        HBQ = 1
        Pod:printDriver("[RLC Sapphire] Hold key to Apply Handbrakes.")
        timer("HB_Check",1000)
    }elseif(!HandBrake & HBQ){
        HBQ = 0
    }
    
    #Train Brake Force Calculation
    if((MPH>Threshold_Hard)&!Locked){
        if(CarCount<1){
            CarCount = E:extraProps(CarCount_Init)
        }
        local TBF = CarCount*(90-BrakeLine)*MaxTrainBrakeForce
        local LBF = ((90-BrakeLine)>LocoBrakePressure ? (90-BrakeLine) : LocoBrakePressure)*MaxLocoBrakeForce
        BrakingForce = sign(V)*(LBF+TBF)
        
    }else{
        BrakingForce = 0
        #LocoBrakingForce = 0
    }
    
    #------------------
    #WheelSlip & Sander
    #------------------
    if(Sander & !SandQ){
        SandQ = 1
        Trig = 1
        Sanding = !Sanding
        W:soundPlay(6,Sanding ? 0 : 2, Sanding ? SanderOn : SanderOff)
    }elseif(!Sander & SandQ){
        SandQ = 0
    }
    
    if(ETC!=2 & (Reverser!=0) & !Brake & !Dynamics){
        
        #Sander
#[        if(Sander & !SandQ){
            SandQ = 1
            W:soundPlay(6,0,SanderOn)
            Trig = 1
        }elseif(!Sander & SandQ){
            SandQ = 0
            W:soundPlay(6,2,SanderOff)
            Trig = 1
        }]#
        
        #Wheelslip
        local Throttle = min(RealNotch,Notch)
        if((Throttle>4) & (MPH<10) & !WSQ){
            local SpeedThreshold = (Throttle - 4 - 2*Sanding)*2.5
            
            WheelSlippable = MPH<SpeedThreshold
        }else{
            WheelSlippable = 0
        }
        if(WheelSlippable & !WheelSlip){
            if(random()<(Sanding ? WheelSlipProb/2 : WheelSlipProb)){
                WheelSlip = 1
                local Snd = WSC ? WheelSlipSound1 : WheelSlipSound2
                soundPlay(7,5,Snd)
                WSC = !WSC
                timer("WheelSlipEnd",sdr(Snd))
            }
        }elseif(!WheelSlippable & WheelSlip){
            WheelSlip = 0
            
            stoptimer("WheelSlipEnd")
            soundStop(7,1)
            timer("WheelSlipStart",1000)
        }
        if(WheelSlip){
            local TEMUL = ETC ? 0.5 : 0.25
            TE *= TEMUL
        }
        
        
    }else{
        WheelSlip = 0
        
    }
    
    #=================
    #Force Application
    #=================
    
    Force = TE - BrakingForce - DynaForce 
    W:applyForce(-E:up()*(Force))
    
    Load = (floor(100*(abs(TE) - abs(DynaForce))/(TE_Starting*16)))
    #==============
    #MU Info Output
    #==============
    
    local HP_Forward = Horsepower + RearPlugIn[7,number]
    local HP_Backward = Horsepower + FrontPlugIn[7,number]
    local Comps_Forward = 1 + RearPlugIn[8,number]
    local Comps_Backward  = 1 + FrontPlugIn[8,number] 
    
    if(MU_Master){
        local ThrottleMU = (Dynamics ? DynaNotch : Notch)*1.25
        RearPlugOut = array(-Reverser,ThrottleMU,0,Dynamics,Trig,Sanding,HP_Backward,Comps_Backward,MainRes)
        FrontPlugOut = array(Reverser,ThrottleMU,0,Dynamics,Trig,Sanding,HP_Forward,Comps_Forward,MainRes)
    }else{
        RearPlugOut = FrontPlugIn:clone()
        FrontPlugOut = RearPlugIn:clone()
        
        RearPlugOut[7,number] = HP_Backward
        FrontPlugOut[7,number] = HP_Forward
        
        RearPlugOut[8,number] = Comps_Backward
        FrontPlugOut[8,number] = Comps_Forward
        
    }
    
}
    if(Load < 70 & Clag){ClagLow = 1}
    else{ClagLow = 0 }
    if(Load > 70 & Clag){ClagHigh = 1} 
    else{ClagHigh = 0 }
    if(CarCount > 11){
    Carwarn = 1     }
    MPH*7 == Feet
    if(Load < -10){DynaClag = 1} 
    else{DynaClag = 0 }
    
#Handbrake Check
if(clk("HB_Check")){
    if(HandBrake){
        local Ents = E:getConstraints()
        foreach(K,V:entity = Ents){
            V:propPhysicalMaterial("rubber")
        }
        Pod:printDriver("[RLC Sapphire]: Handbrakes Applied.")
        Pod:soundPlay(1,1,Lever_HandBrake)
        HandBrakeOn=1
    }
}

#Lever Unlock Indicator
Unlocked = On&(RealNotch==0)

#=============
#Chat Commands
#=============

if(chatClk(O)|chatClk(Driver)){
    Speaker = lastSpoke()
    LS = lastSaid()
    
    local Sentence = LS:explode(" ")
    local CMD = Sentence[1,string]
    
    switch(CMD){
        case ".engine",
            if(Speaker==O){
                SQ = 1
                
                Starting = (Sentence[2,string]=="") ? !Starting : Sentence[2,string]:toNumber()
                if(Starting){
                    local Snd = (FuelSaver & SplitShutDowns) ? (LowIdling ? Startup:sub(1,Startup:length()-4) + "_low.wav" : Startup) : Startup
                    W:soundPlay(0,0,Snd)
                    timer("run",10*floor(soundDuration(Snd)*50) - 500)
                    timer("startclag",StartupClagStart*1000)
                    Speaker:printProper("[RLC Sapphire]: Starting Engine.")
                    
                    if(DPM){
                        #print("Run")
                        DPMS = Snd
                        timer("dpm",sdr(Snd))
                    }
                }else{
                    On = 0
                    local Snd = (FuelSaver & SplitShutDowns) ? (LowIdling ? Shutdown:sub(1,Shutdown:length()-4) + "_low.wav" : Shutdown) : Shutdown
                    W:soundPlay(0,0,Snd)
                    stopAllTimers()
                    timer("cool",10*floor(soundDuration(Snd)*50))
                    Speaker:printProper("[RLC Sapphire]: Shutting Engine Down.")
                    
                    if(DPM){
                        DPMS = Snd
                        timer("dpm",sdr(Snd))
                    }
                }
            }
            hideChat(1)
            break
        case ".notch",
            if(MU_Master & On){
                Notch = clamp(Sentence[2,string]:toNumber(),0,8)
                TQ = tq_evaluate(RealNotch,Notch)
                RealNotch = startTransition(RealNotch,Notch)
                TQ = tq_evaluate(RealNotch,Notch)
                RealNotch = startTransition(RealNotch,Notch)
                Speaker:printProper("[RLC Sapphire]: Setting Notch to " + Notch:toString() + ".")
                Trig2 = 1
            }elseif(On & !MU_Master){
                stoptimer("mu_recheck")
                timer("mu_recheck",1000)
            }
            hideChat(1)
            break
        case ".brake",
            if(MU_Master & On){
                if(Sentence[2,string]==""){
                    Emergency = 1
                    EqualRes = BrakeLine = 0
                    
                    local Ents = E:getConstraints()
                    foreach(K,V:entity=Ents){
                        V:propPhysicalMaterial("slipperyslime")
                    }
                    AB16M_Notch = 2
                    Pod:soundPlay(5,0,EmergencyBrakeSound)
                    Pod:soundPlay(1,1,AirBrakeType ? Lever_26L : Lever_16M)
                    
                    
                    Notch = 0
                    TQ = tq_evaluate(RealNotch,Notch)
                    RealNotch = startTransition(RealNotch,Notch)
                    Speaker:printProper("[RLC Sapphire]: Applying Emergency Brake.")
                    Trig2 = 1
                }else{
                    local ToPressure = clamp(Sentence[2,string]:toNumber(),0,90)
                    if(!AirBrakeType){AB16M_Notch = 0}
                    EqualRes = 90-ToPressure
                    Speaker:printProper("[RLC Sapphire]: Setting " + ToPressure:toString() + " lb Application ("+EqualRes:toString()+" ER psi).")
                }
                hideChat(1)
                #Trig2 = 1
            }
            break
        case ".reverser",
            if(MU_Master & On){
                Reverser = clamp(Sentence[2,string]:toNumber(),-1,1)
                Speaker:printProper("[RLC Sapphire]: Setting Reverser to " + Reverser:toString() + ".")
                Trig2 = 1
            }
            hideChat(1)
            break
        case ".dynamics",
            if(On & MU_Master){
                if(DynamicsEnable){
                    local CanEngage = (DynaNotch==0) ? (RealNotch==0) : 1
                    if((Reverser!=0) & CanEngage){
                        
                        DynaNotch = Sentence[2,string]:toNumber()
                        Dynamics = DynaNotch > 0
                        Speaker:printProper("[RLC Sapphire]: Setting Dynamic Brakes to Notch " + Sentence[2,string] + ".")
                    }else{
                        Speaker:printProper("[RLC Sapphire]: Dynamic Brake Condition Invalid!")
                    }
                }else{
                    Speaker:printProper("[RLC Sapphire]: Locomotive has no Dynamic Brakes!")
                }
            }elseif(On & !MU_Master){
                stoptimer("mu_recheck")
                timer("mu_recheck",1000)
            }
            hideChat(1)
            break
        case ".handbrake",
            if(MU_Master){
                local Ents = E:getConstraints()
                foreach(K,V:entity = Ents){
                    V:propPhysicalMaterial("rubber")
                }
                Speaker:printProper("[RLC Sapphire]: Handbrakes Applied.")
                Pod:soundPlay(1,1,Lever_HandBrake)
            }
            hideChat(1)
            break
        case ".controls",
            if(MU_Master){
                for(K=1,ControlPrintOrder:count()){
                    local ControlName = ControlPrintOrder[K,string]
                    local X = Controls[ControlName,string]
                    if(Routing[ControlName,number]){
                        Speaker:printProper(ControlName + ": Shift + " + X)
                    }else{
                        Speaker:printProper(ControlName + ": " + X)
                    }
                }
            }
            hideChat(1)
            break
        case ".superice",
            if(MU_Master){
                E:abRelease()
                Speaker:printProper("[RLC Sapphire]: Consist has been Super Iced.")
            }
            hideChat(1)
            break
        case ".count",
            if(MU_Master){Speaker:printProper("[RLC Sapphire]: Your Train has " + CarCount:toString() + " cars.")}
            hideChat(1)
            break
        case ".weight",
            if(MU_Master){
                local TMass = 0
                local TProps = E:getConstraints()
                for(N=1,TProps:count()){
                    TMass += TProps[N,entity]:mass()
                }
                TMass -= 80000
                local SCE = round(TMass/25000,1)
                Speaker:printProper("[RLC Sapphire]: Total Car Mass: " + SCE:toString() + " SCE.")
            }
            hideChat(1)
            break
        case ".switching",
            if(MU_Master){
                Switching = Sentence[2,string]:toNumber()
                if(Switching){
                    Speaker:printProper("[RLC Sapphire]: Switching Mode Engaged.")
                }else{
                    Speaker:printProper("[RLC Sapphire]: Switching Mode Disengaged.")
                }
                hideChat(1)
            }
            break
        default,
            break
    }
    if(Carwarn > 0){Pod:printDriver("[RLC Sapphire]: NOTE: IT'S NOT WISE TO RUN OVER 11 CARS WITH A SERVER POPULATED WITH PEOPLE, MOST SERVERS HAVE A RULE THAT DOESN'T ALLOW 11 OR MORE CARS. YOU MIGHT BE BANNED OR LAG THE SERVER!")}
}
if(On<1){


interval(500)
}
if(dupefinished()){
   
    #[
        Coded by STEAM_0:1:39618360 (Crypto)
        Selling this to other people makes me sad :(
    ]#
   
    #[ [Configuration] ]#
    CFG_HourOffset = 8
   
    #[ [EGP] ]#
    EGPClock:egpClear()
   
    EGPClock:egpBox(1,vec2(256,256),vec2(512,512))
    EGPClock:egpColor(1,vec(0,0,0))
   
    EGPClock:egpBox(2,vec2(256,256),vec2(512,512))
    EGPClock:egpColor(2,vec(33,33,33))
    EGPClock:egpMaterial(2,"gui/gradient_up")
   
    EGPClock:egpCircle(3,vec2(256,256),vec2(192,192))
    EGPClock:egpColor(3,vec(44,44,44))
   
    EGPClock:egpCircle(4,vec2(256,256),vec2(182,182))
    EGPClock:egpColor(4,vec(66,66,66))
   
    EGPClock:egpBox(5,vec2(0,-56),vec2(2,182 - 32))
    EGPClock:egpColor(5,vec(128,128,128))
   
    EGPClock:egpCircle(7,vec2(256,256),vec2(16,16))
    EGPClock:egpColor(7,vec(44,44,44))
    EGPClock:egpParent(5,7)
   
    EGPClock:egpBox(8,vec2(0,-36),vec2(4,182 - 64))
    EGPClock:egpColor(8,vec(128,128,128))
    EGPClock:egpCircle(9,vec2(256,256),vec2(16,16))
    EGPClock:egpColor(9,vec(44,44,44))
    EGPClock:egpParent(8,9)
   
    EGPClock:egpBox(10,vec2(0,-12),vec2(6,182 - 96))
    EGPClock:egpColor(10,vec(128,128,128))
    EGPClock:egpCircle(11,vec2(256,256),vec2(16,16))
    EGPClock:egpColor(11,vec(44,44,44))
    EGPClock:egpParent(10,11)
   
    EGPClock:egpCircle(11,vec2(256,256),vec2(16,16))
    EGPClock:egpColor(30,vec(44,44,44))
    
    FirstPos = vec2(256,256 - 162)
    EGPClock:egpText(12,"12",FirstPos)
    EGPClock:egpSize(12,30)
    EGPClock:egpColor(12,vec(128,128,128))
    EGPClock:egpAlign(12,1,1)
   
    NumPoints = 1
   
    for(I = 30,360,30)
    {
        Point = vec(FirstPos:x(),FirstPos:y(),512*512):rotateAroundAxis(vec(256,256,512*512),I)
        EGPClock:egpText(EGPClock:egpNumObjects() + 2,NumPoints:toString(),vec2(Point))
        EGPClock:egpSize(EGPClock:egpNumObjects() + 1,30)
        EGPClock:egpColor(EGPClock:egpNumObjects() + 1,vec(128,128,128))
        EGPClock:egpAlign(EGPClock:egpNumObjects() + 1,1,1)
        NumPoints++
    }
  
}

